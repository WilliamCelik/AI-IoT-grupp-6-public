# NOTE:
# - Secrets, API keys, and bucket names have been redacted or replaced.
# - DO NOT commit sensitive AWS identifiers, API keys, or ARNs to public repositories.

import json
import urllib3
import logging
import boto3

# Setup
logger = logging.getLogger()
logger.setLevel(logging.DEBUG)
http = urllib3.PoolManager()
s3 = boto3.client('s3')
BUCKET_NAME = "YOUR_BUCKET_NAME"  # Masked for public sharing

# Entry point
def lambda_handler(event, context):
    try:
        logger.debug('Received event: %s', json.dumps(event))
    except Exception:
        logger.debug("Received event (could not encode full content due to Unicode).")

    if "sessionState" in event:
        return handle_lex_request(event)
    elif "httpMethod" in event:
        return handle_api_gateway_request(event)
    else:
        return generate_lex_response("Invalid request source", fulfillment_state="Failed")

# Main Lex logic
def handle_lex_request(event):
    try:
        intent_name = event.get('sessionState', {}).get('intent', {}).get('name')
        logger.info(f"Intent name received: {intent_name}")
    except Exception as e:
        logger.error("Failed to extract intent name.")
        raise e

    if intent_name == "Getweedinfo":
        try:
            weed_slot = (
                event.get('sessionState', {})
                     .get('intent', {})
                     .get('slots', {})
                     .get('Weedname', {})
                     .get('value', {})
                     .get('interpretedValue')
            )

            logger.info(f"Weedname slot received: {weed_slot}")

            if not weed_slot:
                logger.warning("Slot 'Weedname' was not filled or interpreted.")
                return generate_lex_error_response("Getweedinfo", "Jag kunde inte tolka v√§xtnamnet.")

            return handle_weed_request(weed_slot)

        except Exception as e:
            logger.exception("Error in Getweedinfo intent.")
            return generate_lex_error_response("Getweedinfo", "Fel uppstod vid h√§mtning av v√§xtinformation.")
    elif intent_name == "GetHerbicideInfo":
        try:
            weed_slot = (
                event.get('sessionState', {})
                     .get('intent', {})
                     .get('slots', {})
                     .get('Weedname', {})
                     .get('value', {})
                     .get('interpretedValue')
            )

            logger.info(f"Weedname slot received for herbicide info: {weed_slot}")

            if not weed_slot:
                return generate_lex_error_response("GetHerbicideInfo", "Jag kunde inte tolka v√§xtnamnet.")

            return handle_herbicide_info_request(weed_slot)

        except Exception:
            logger.exception("Error handling GetHerbicideInfo intent")
            return generate_lex_error_response("GetHerbicideInfo", "Ett fel intr√§ffade vid h√§mtning av bek√§mpningsinfo.")

    elif intent_name == "Weatherinfo":
        try:
            slots = event['sessionState']['intent']['slots']
            city = slots.get("City", {}).get("value", {}).get("interpretedValue")
            date = slots.get("Date", {}).get("value", {}).get("interpretedValue")
            locale = event["bot"]["localeId"]

            logger.info(f"City: {city}, Date: {date}, Locale: {locale}")

            # Kontrollera att b√•da v√§rden finns
            if not city or not date:
                return generate_lex_error_response("Weatherinfo", "Jag kunde inte tolka ort eller datum korrekt.")

            lon, lat = get_coordinates(city)
            if lon is None or lat is None:
                logger.warning(f"Kunde inte hitta koordinater f√∂r orten '{city}'")
                return generate_lex_error_response("Weatherinfo", f"Kunde inte hitta v√§derdata f√∂r orten '{city}'. Kontrollera stavningen.")

            weather_data = fetch_weather_data(lon, lat, date)
            if weather_data is None:
                logger.warning(f"Ingen v√§derdata tillg√§nglig f√∂r {city} den {date}")
                return generate_lex_error_response("Weatherinfo", f"Ingen v√§derprognos tillg√§nglig f√∂r {city} den {date}")

            session_attributes = {
                "last_city": city,
                "last_date": date
            }

            return generate_lex_response(weather_data, city, date, locale, session_attributes)

        except Exception:
            logger.exception("Error handling Weatherinfo intent")
            return generate_lex_error_response("Weatherinfo", "N√•got gick fel n√§r v√§derdata skulle h√§mtas.")

    elif intent_name == "Music":
        return {
            "sessionState": {
                "dialogAction": {"type": "Close"},
                "intent": {"name": "Music", "state": "Fulfilled"}
            },
            "messages": [{
                "contentType": "CustomPayload",
                "content": "üé∂ Jag kan sjunga! H√§r √§r min s√•ng! Hoppas du gillar den:\n\n[üéµ V√§derAnnika sjunger](https://www.youtube.com/watch?v=dwCs3rmnymM)"
            }]
        }
        

    elif intent_name == "FindBestSprayDay":
        try:
            slots = event['sessionState']['intent']['slots']
            city = slots.get("City", {}).get("value", {}).get("interpretedValue")
            if not city:
                return generate_lex_error_response("FindBestSprayDay", "Jag beh√∂ver veta vilken ort du menar.")

            next_date, explanation = find_next_spray_day(city)
            if next_date:
                message = (
                    f"\n\n üìÜ N√§sta dag med bra bek√§mpningsf√∂rh√•llanden i {city} √§r {next_date}.  \n\n"
                    f"{explanation.replace('\n', '  \n')}"
                )
            else:
                message = f"üö´ Inga bra bek√§mpningsdagar hittades i {city} de n√§rmaste 10 dagarna."

            return {
                "sessionState": {
                    "dialogAction": {"type": "Close"},
                    "intent": {"name": "FindBestSprayDay", "state": "Fulfilled"}
                },
                "messages": [{"contentType": "PlainText", "content": message}]
            }

        except Exception:
            logger.exception("Fel vid s√∂kning efter b√§sta bek√§mpningsdag")
            return generate_lex_error_response("FindBestSprayDay", "N√•got gick fel n√§r vi f√∂rs√∂kte hitta b√§sta bek√§mpningsdag.")


    elif intent_name == "CheckSprayConditions":
        try:
            slots = event.get('sessionState', {}).get('intent', {}).get('slots') or {}
            session_attributes = event['sessionState'].get('sessionAttributes', {})

            city = (slots.get('City') or {}).get('value', {}).get('interpretedValue') or session_attributes.get("last_city")
            date = (slots.get('Date') or {}).get('value', {}).get('interpretedValue') or session_attributes.get("last_date")

            locale = event["bot"]["localeId"]

            if not city or not date:
                return generate_lex_error_response("CheckSprayConditions", "Jag saknar information om ort eller datum.")

            lon, lat = get_coordinates(city)
            if lon is None or lat is None:
                logger.warning(f"Kunde inte hitta koordinater f√∂r orten '{city}'")
                return generate_lex_error_response("CheckSprayConditions", f"Jag kunde inte hitta platsen '{city}'. Kontrollera stavningen.")

            weather_data = fetch_weather_data(lon, lat, date)
            if weather_data is None:
                logger.warning(f"Ingen v√§derdata tillg√§nglig f√∂r {city} den {date}")
                return generate_lex_error_response("CheckSprayConditions", f"Ingen v√§derdata tillg√§nglig f√∂r {city} den {date}. Prova ett annat datum.")

            spray_ok, analysis = evaluate_spray_conditions(weather_data)

            message = (
                f"\n\nüß™ Bed√∂mning f√∂r bek√§mpning i {city} den {date}:\n\n"
                f"{analysis.replace('\n', '  \n')}"
            )

            return {
                "sessionState": {
                    "dialogAction": {"type": "Close"},
                    "intent": {"name": "CheckSprayConditions", "state": "Fulfilled"}
                },
                "messages": [{"contentType": "PlainText", "content": message}]
            }

        except Exception:
            logger.exception("Error handling CheckSprayConditions intent")
            return generate_lex_response(None, "ok√§nd plats", "ok√§nt datum", "sv_SE")

def handle_weed_request(weed_name):
    try:
        logger.info(f"F√∂rs√∂ker h√§mta ogr√§sdata f√∂r: {weed_name}")
        # F√∂rs√∂k med flera namnvarianter
        name_variants = [
            weed_name,
            weed_name.capitalize(),
            weed_name.upper()
        ]

        for name in name_variants:
            try:
                key = f"Ogr√§sDB/Data/{name}.json"
                response = s3.get_object(Bucket=BUCKET_NAME, Key=key)
                weed_data = json.loads(response['Body'].read())

                image_path = weed_data.get('Bild', f"Ogr√§sDB/Images/{name}.jpg")
                image_url = f"https://{BUCKET_NAME}.s3.eu-central-1.amazonaws.com/{image_path}"

                message = (
                    f"\n\nüåø H√§r √§r informationen om {weed_data['Ogr√§snamn']} fr√•n jordbruksverkets ogr√§sdatabas:  \n\n"
                    f"\n\nLatinskt namn: {weed_data.get('Latinskt namn', 'ok√§nt')}\n\n"
                    f"Artbeskrivning:\n{weed_data.get('Artbeskrivning', 'Ingen beskrivning tillg√§nglig')}\n\n"
                    f"F√∂rekomst:\n{weed_data.get('F√∂rekomst', 'Ingen information tillg√§nglig')}\n\n"
                    f"Giftighet:\n{weed_data.get('Giftighet', 'Ingen information tillg√§nglig')}\n\n"
                    f"Smaklighet:\n{weed_data.get('Smaklighet', 'Ingen information tillg√§nglig')}\n\n"
                    f"N√§ringsv√§rde:\n{weed_data.get('N√§ringsv√§rde', 'Ingen information tillg√§nglig')}\n\n"
                    f"Bild:\n{image_url}"
                )

                return {
                    "sessionState": {
                        "dialogAction": {"type": "Close"},
                        "intent": {"name": "Getweedinfo", "state": "Fulfilled"}
                    },
                    "messages": [{"contentType": "PlainText", "content": message}]
                }

            except s3.exceptions.NoSuchKey:
                continue  # prova n√§sta variant

        # Om ingen variant hittades
        logger.warning(f"Ingen ogr√§sfil hittades f√∂r: {weed_name}")
        return generate_lex_error_response("Getweedinfo", f"Kunde inte hitta information om '{weed_name}'.")

    except Exception as e:
        logger.exception(f"Fel vid h√§mtning av ogr√§sdata f√∂r '{weed_name}'")
        return generate_lex_error_response("Getweedinfo", f"Fel vid h√§mtning av information om '{weed_name}'.")

def evaluate_spray_conditions(weather_data):
    wind = weather_data.get("wind_speed", 999)
    humidity = weather_data.get("humidity", 999)
    temp = weather_data.get("temperature", -999)

    status = []
    allow = True

    # Vind
    if wind < 3:
        status.append("‚úÖ **Vindhastighet:** Spridning godk√§nd.\n")
    elif 3 <= wind <= 5:
        status.append("‚ö†Ô∏è **Vindhastighet:** Begr√§nsad spridning m√∂jlig vid l√•g luftfuktighet.\n")
    else:
        status.append("‚ùå **Vindhastighet:** F√∂r h√∂g. Endast mekanisk bek√§mpning m√∂jlig.\n")
        allow = False

    # Luftfuktighet
    if humidity < 40:
        status.append("‚ùå **Luftfuktighet:** F√∂r l√•g ‚Üí risk f√∂r avdunstning.\n")
        allow = False
    elif 40 <= humidity <= 80:
        status.append("‚úÖ **Luftfuktighet:** Inom optimalt intervall.\n")
    else:
        status.append("‚ùå **Luftfuktighet:** F√∂r h√∂g ‚Üí risk f√∂r avrinning.\n")
        allow = False

    # Temperatur
    if temp < 5:
        status.append("‚ùå **Temperatur:** F√∂r kallt, l√•g effekt.\n")
        allow = False
    elif 5 <= temp <= 25:
        status.append("‚úÖ **Temperatur:** Inom optimalt intervall.\n")
    else:
        status.append("‚ùå **Temperatur:** F√∂r varmt, risk f√∂r avdunstning.\n")
        allow = False

    # Sammanfattning
    if allow:
        status.append("\n‚úÖ Sammantaget: Bek√§mpning √§r m√∂jlig.")
    else:
        status.append("\nüö´ Sammantaget: Bek√§mpning rekommenderas inte.")

    return allow, "".join(status)

from datetime import datetime, timedelta

def find_next_spray_day(city):
    lon, lat = get_coordinates(city)
    if lon is None or lat is None:
        return None, f"Kunde inte hitta koordinater f√∂r orten '{city}'."

    for i in range(10):  # Kolla 10 dagar fram√•t
        date = (datetime.utcnow() + timedelta(days=i)).date().isoformat()
        weather = fetch_weather_data(lon, lat, date)
        if weather:
            ok, analysis = evaluate_spray_conditions(weather)
            if ok:
                return date, analysis

    return None, ""
   

def handle_herbicide_info_request(weed_name):
    try:
        logger.info(f"F√∂rs√∂ker h√§mta bek√§mpningsdata f√∂r: {weed_name}")
        name_variants = [weed_name, weed_name.capitalize(), weed_name.upper()]

        for name in name_variants:
            try:
                key = f"Ogr√§sDB/Data/{name}_bek√§mpning.json"
                response = s3.get_object(Bucket=BUCKET_NAME, Key=key)
                treatment_data = json.loads(response['Body'].read())

                # üß™ Extra debug
                logger.info(f"Behandlingsdata: {json.dumps(treatment_data, ensure_ascii=False)}")

                # H√§mta l√§nkar
                links = treatment_data.get("L√§nkar", {})
                kemi_link = links.get("KemI", None)
                producer_link = links.get("Producent", None)

                message = (
                    f"\n\nüß¥Bek√§mpningsinfo f√∂r {weed_name} fr√•n jordbruksverkets ogr√§sdatabas  \n\n"
                    f"\n\n Medel: {treatment_data.get('Namn', 'ingen info')}\n\n"
                    f" Verkansgrad: {treatment_data.get('Verkansgrad', 'ingen info')}\n\n"
                    f" Behandlingstidpunkt: {treatment_data.get('Behandlingstidpunkt', 'ingen info')}\n\n"
                    f" Diverse: {treatment_data.get('Diverse', 'ingen info')}\n\n"
                    f"üîó **L√§nkar:**\n"
                )
            
                if kemi_link:
                    message += f"- [KemI]({kemi_link})\n"
                else:
                    message += "- KemI: Ingen l√§nk tillg√§nglig\n"

                if producer_link:
                    message += f"- [Producent]({producer_link})\n"
                else:
                    message += "- Producent: Ingen l√§nk tillg√§nglig\n"

                return {
                    "sessionState": {
                        "dialogAction": {"type": "Close"},
                        "intent": {"name": "GetHerbicideInfo", "state": "Fulfilled"}
                    },
                    "messages": [
                        {
                            "contentType": "PlainText",
                            "content": message
                        }
                    ]
                }

            except s3.exceptions.NoSuchKey:
                continue

        return generate_lex_error_response("GetHerbicideInfo", f"Kunde inte hitta bek√§mpningsinfo f√∂r '{weed_name}'.")

    except Exception as e:
        logger.exception(f"Fel vid h√§mtning av bek√§mpningsdata f√∂r '{weed_name}'")
        return generate_lex_error_response("GetHerbicideInfo", f"Fel vid h√§mtning av bek√§mpningsinfo f√∂r '{weed_name}'.")

# Lex response builder for errors
def generate_lex_error_response(intent_name, message):
    return {
        "sessionState": {
            "dialogAction": {"type": "Close"},
            "intent": {"name": intent_name, "state": "Failed"}
        },
        "messages": [{"contentType": "PlainText", "content": message}]
    }

# API Gateway fallback handler
def handle_api_gateway_request(event):
    method = event.get("httpMethod", "").upper()

    if method == "OPTIONS":
        return {
            "statusCode": 200,
            "headers": cors_headers(),
            "body": json.dumps({"message": "CORS preflight successful"})
        }

    elif method == "POST" and event.get("path") == "/identify":
        return handle_image_identification(event)

    elif method == "POST":
        body = json.loads(event['body'])
        city = body.get("City")
        date = body.get("Date")
        return process_weather_request(city, date)

    return {
        "statusCode": 405,
        "headers": cors_headers(),
        "body": json.dumps({"error": "Method Not Allowed"})
    }

# For manual API Gateway weather requests
def process_weather_request(city, date):
    lon, lat = get_coordinates(city)
    if lon is None or lat is None:
        return {"statusCode": 400, "body": json.dumps({"error": f"Could not find coordinates for {city}"})}

    weather_data = fetch_weather_data(lon, lat, date)
    if weather_data is None:
        return {"statusCode": 404, "body": json.dumps({"error": f"No weather data available for {city} on {date}"})}

    return {"statusCode": 200, "body": json.dumps({"message": f"Weather forecast for {city} on {date}: {weather_data}"})}

# Lex response builder for weather
from datetime import datetime  # Se till att detta redan finns √∂verst i ditt script

def generate_lex_response(weather_data, city, date, locale="en_US", session_attributes=None):
    time_iso = weather_data.get('time') if weather_data else None
    formatted_time = ""
    if time_iso:
        dt = datetime.fromisoformat(time_iso.replace("Z", "+00:00"))
        formatted_time = dt.strftime("kl %H:%M UTC")

    messages = {
        "en_US": {
            "no_data": f"Sorry, I couldn't retrieve weather data for {city} on {date}.",
            "forecast": (
                f"Weather forecast for {city} on {date} ({formatted_time}):\n\n"
                f"Temperature: {weather_data.get('temperature', 'N/A')}¬∞C\n\n"
                f"Rainfall: {weather_data.get('rainfall', 'N/A')} mm\n\n"
                f"Wind Speed: {weather_data.get('wind_speed', 'N/A')} m/s\n\n"
                f"Humidity: {weather_data.get('humidity', 'N/A')}%\n"
            ),
            "closing": "Would you like to check the weather for another location or day?"
        },
        "sv_SE": {
            "no_data": f"Tyv√§rr kunde jag inte h√§mta v√§derdata f√∂r {city} den {date}.",
            "forecast": (
                f"\n\nüåç V√§derprognos f√∂r {city} {date} ({formatted_time})\n\n"
                f"üå°Ô∏è Temperatur:\n{weather_data.get('temperature', 'N/A')}¬∞C\n\n"
                f"üåßÔ∏è Nederb√∂rd:\n{weather_data.get('rainfall', 'N/A')} mm\n\n"
                f"üí® Vindhastighet:\n{weather_data.get('wind_speed', 'N/A')} m/s\n\n"
                f"üíß Luftfuktighet:\n{weather_data.get('humidity', 'N/A')}%\n\n"
                f"üå´Ô∏è Molnt√§cke:\n{weather_data.get('cloud_cover', 'N/A')}%\n\n"
                f"üß≠ Vindriktning:\n{weather_data.get('wind_direction', 'N/A')}¬∞\n\n"
                f"üå¨Ô∏è Byvind:\n{weather_data.get('gust_speed', 'N/A')} m/s"
            ),
            "closing": "Vill du kolla v√§dret f√∂r n√•gon annan plats eller dag?"
        }
    }

    lang = messages.get(locale, messages["en_US"])

    if not weather_data:
        return {
            "sessionState": {
                "dialogAction": {"type": "Close"},
                "intent": {"name": "Weatherinfo", "state": "Failed"}
            },
            "messages": [{"contentType": "PlainText", "content": lang["no_data"]}]
        }

    return {
        "sessionState": {
            "dialogAction": {"type": "Close"},
            "intent": {"name": "Weatherinfo", "state": "Fulfilled"},
            "sessionAttributes": session_attributes or {}
        },
        "messages": [
            {"contentType": "PlainText", "content": lang["forecast"]},
            {"contentType": "PlainText", "content": lang["closing"]}
        ]
    }



# Geocoding
def get_coordinates(city):
    api_key = 'YOUR_OPENCAGE_API_KEY'  # Masked
    url = f"https://api.opencagedata.com/geocode/v1/json?q={city}&key={api_key}"
    response = http.request('GET', url)
    if response.status == 200:
        data = json.loads(response.data.decode('utf-8'))
        if data['results']:
            return data['results'][0]['geometry']['lng'], data['results'][0]['geometry']['lat']
    return None, None

# Image recognition
def handle_image_identification(event):
    try:
        rekognition = boto3.client('rekognition', region_name='eu-central-1')
        project_version_arn = 'YOUR_PROJECT_VERSION_ARN'  # Masked ARN

        import base64
        image_bytes = base64.b64decode(event["body"])

        response = rekognition.detect_custom_labels(
            ProjectVersionArn=project_version_arn,
            Image={'Bytes': image_bytes}
        )

        if not response["CustomLabels"]:
            result = "üßê Jag kunde inte identifiera n√•got ogr√§s i bilden. √Ñr du s√§ker p√• att det √§r en v√§xt?"
            return {
                "statusCode": 200,
                "headers": cors_headers(),
                "body": json.dumps({"result": result})
            }
        else:
            label = response["CustomLabels"][0]["Name"]
            confidence = round(response["CustomLabels"][0]["Confidence"], 1)
            result = f"üå± Det ser ut som: **{label}** ({confidence}% s√§kerhet)"
            return {
                "statusCode": 200,
                "headers": cors_headers(),
                "body": json.dumps({"label": label, "result": result})
            }

    except Exception as e:
        logger.exception("Fel vid bildidentifiering")
        return {
            "statusCode": 500,
            "headers": cors_headers(),
            "body": json.dumps({"error": str(e)})
        }

# Weather API
from datetime import datetime

def fetch_weather_data(lon, lat, date):
    logger.debug(f"Fetching weather data for lon: {lon}, lat: {lat}, date: {date}")
    url = f"https://opendata-download-metfcst.smhi.se/api/category/pmp3g/version/2/geotype/point/lon/{round(lon, 4)}/lat/{round(lat, 4)}/data.json"
    response = http.request('GET', url)
    logger.debug(f"API Response Status: {response.status}")

    if response.status == 200:
        forecast_data = json.loads(response.data.decode('utf-8'))

        # Vi vill ha datapunkten som ligger n√§rmast kl 10:00 UTC samma dag
        target_hour = 10
        closest_entry = None
        smallest_diff = float('inf')

        for entry in forecast_data["timeSeries"]:
            entry_time = datetime.fromisoformat(entry["validTime"].replace("Z", "+00:00"))
            if entry_time.date().isoformat() == date:
                diff = abs(entry_time.hour - target_hour)
                if diff < smallest_diff:
                    smallest_diff = diff
                    closest_entry = entry

        if closest_entry:
            data = {param["name"]: param["values"][0] for param in closest_entry["parameters"]}
            logger.debug(f"Selected time: {closest_entry['validTime']} for weather data.")
            return {
                "temperature": data.get("t"),
                "rainfall": data.get("pmean"),
                "wind_speed": data.get("ws"),
                "humidity": data.get("r"),
                "pressure": data.get("msl"),
                "cloud_cover": data.get("tcc_mean"),
                "wind_direction": data.get("wd"),
                "gust_speed": data.get("gust"),
                "time": closest_entry['validTime'] 
            }

    logger.warning("No matching forecast data found.")
    return None


# CORS
def cors_headers():
    return {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "OPTIONS, GET, POST",
        "Access-Control-Allow-Headers": "Content-Type"
    }
